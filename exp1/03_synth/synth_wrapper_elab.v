
// Generated by Cadence Genus(TM) Synthesis Solution GENUS15.20 - 15.20-p004_1
// Generated on: May 24 2025 12:41:48

// Verification Directory fv/synth_wrapper 

module fulladder(X, Y, Ci, S, Co);
  input X, Y, Ci;
  output S, Co;
  wire X, Y, Ci;
  wire S, Co;
  wire w1, w2, w3;
  xor G1 (w1, X, Y);
  xor G2 (S, w1, Ci);
  and G3 (w2, w1, Ci);
  and G4 (w3, X, Y);
  or G5 (Co, w2, w3);
endmodule

module ripple_adder(X, Y, S, Co, Cin);
  input [3:0] X, Y;
  input Cin;
  output [3:0] S;
  output Co;
  wire [3:0] X, Y;
  wire Cin;
  wire [3:0] S;
  wire Co;
  wire w1, w2, w3;
  fulladder u1(X[0], Y[0], Cin, S[0], w1);
  fulladder u2(X[1], Y[1], w1, S[1], w2);
  fulladder u3(X[2], Y[2], w2, S[2], w3);
  fulladder u4(X[3], Y[3], w3, S[3], Co);
endmodule

module bmux(ctl, in_0, in_1, z);
  input ctl, in_0, in_1;
  output z;
  wire ctl, in_0, in_1;
  wire z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0), .data1 (in_1), .z (z));
endmodule

module bmux_1(ctl, in_0, in_1, z);
  input ctl;
  input [3:0] in_0, in_1;
  output [3:0] z;
  wire ctl;
  wire [3:0] in_0, in_1;
  wire [3:0] z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0[3]), .data1 (in_1[3]), .z
       (z[3]));
  CDN_bmux2 g2(.sel0 (ctl), .data0 (in_0[2]), .data1 (in_1[2]), .z
       (z[2]));
  CDN_bmux2 g3(.sel0 (ctl), .data0 (in_0[1]), .data1 (in_1[1]), .z
       (z[1]));
  CDN_bmux2 g4(.sel0 (ctl), .data0 (in_0[0]), .data1 (in_1[0]), .z
       (z[0]));
endmodule

module synth_wrapper(X, Y, rst_n, clk, S, Cin, Co);
  input [3:0] X, Y;
  input rst_n, clk, Cin;
  output [3:0] S;
  output Co;
  wire [3:0] X, Y;
  wire rst_n, clk, Cin;
  wire [3:0] S;
  wire Co;
  wire [3:0] X_reg;
  wire [3:0] Y_reg;
  wire Cin_reg, Co_reg_44, \S_reg[0]_32 , \S_reg[1]_33 , \S_reg[2]_34 ,
       \S_reg[3]_35 , UNCONNECTED, UNCONNECTED0;
  wire UNCONNECTED1, UNCONNECTED2, UNCONNECTED3, UNCONNECTED4,
       UNCONNECTED5, UNCONNECTED6, UNCONNECTED7, UNCONNECTED8;
  wire UNCONNECTED9, UNCONNECTED10, UNCONNECTED11, UNCONNECTED12, n_15;
  ripple_adder u1(X_reg, Y_reg, {\S_reg[3]_35 , \S_reg[2]_34 ,
       \S_reg[1]_33 , \S_reg[0]_32 }, Co_reg_44, Cin_reg);
  bmux mux_Cin_reg_16_8(.ctl (n_15), .in_0 (Cin), .in_1 (1'b0), .z
       (UNCONNECTED));
  bmux_1 mux_Y_reg_16_8(.ctl (n_15), .in_0 (Y), .in_1 (4'b0000), .z
       ({UNCONNECTED3, UNCONNECTED2, UNCONNECTED1, UNCONNECTED0}));
  bmux_1 mux_X_reg_16_8(.ctl (n_15), .in_0 (X), .in_1 (4'b0000), .z
       ({UNCONNECTED7, UNCONNECTED6, UNCONNECTED5, UNCONNECTED4}));
  bmux mux_Co_16_8(.ctl (n_15), .in_0 (Co_reg_44), .in_1 (1'b0), .z
       (UNCONNECTED8));
  bmux_1 mux_S_16_8(.ctl (n_15), .in_0 ({\S_reg[3]_35 , \S_reg[2]_34 ,
       \S_reg[1]_33 , \S_reg[0]_32 }), .in_1 (4'b0000), .z
       ({UNCONNECTED12, UNCONNECTED11, UNCONNECTED10, UNCONNECTED9}));
  not g1 (n_15, rst_n);
  CDN_flop \S_reg[0] (.clk (clk), .d (\S_reg[0]_32 ), .sena (1'b1),
       .aclr (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (S[0]));
  CDN_flop \S_reg[1] (.clk (clk), .d (\S_reg[1]_33 ), .sena (1'b1),
       .aclr (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (S[1]));
  CDN_flop \S_reg[2] (.clk (clk), .d (\S_reg[2]_34 ), .sena (1'b1),
       .aclr (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (S[2]));
  CDN_flop \S_reg[3] (.clk (clk), .d (\S_reg[3]_35 ), .sena (1'b1),
       .aclr (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (S[3]));
  CDN_flop Co_reg(.clk (clk), .d (Co_reg_44), .sena (1'b1), .aclr
       (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (Co));
  CDN_flop \X_reg_reg[0] (.clk (clk), .d (X[0]), .sena (1'b1), .aclr
       (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (X_reg[0]));
  CDN_flop \X_reg_reg[1] (.clk (clk), .d (X[1]), .sena (1'b1), .aclr
       (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (X_reg[1]));
  CDN_flop \X_reg_reg[2] (.clk (clk), .d (X[2]), .sena (1'b1), .aclr
       (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (X_reg[2]));
  CDN_flop \X_reg_reg[3] (.clk (clk), .d (X[3]), .sena (1'b1), .aclr
       (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (X_reg[3]));
  CDN_flop \Y_reg_reg[0] (.clk (clk), .d (Y[0]), .sena (1'b1), .aclr
       (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (Y_reg[0]));
  CDN_flop \Y_reg_reg[1] (.clk (clk), .d (Y[1]), .sena (1'b1), .aclr
       (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (Y_reg[1]));
  CDN_flop \Y_reg_reg[2] (.clk (clk), .d (Y[2]), .sena (1'b1), .aclr
       (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (Y_reg[2]));
  CDN_flop \Y_reg_reg[3] (.clk (clk), .d (Y[3]), .sena (1'b1), .aclr
       (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (Y_reg[3]));
  CDN_flop Cin_reg_reg(.clk (clk), .d (Cin), .sena (1'b1), .aclr
       (n_15), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (Cin_reg));
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  reg  z;
  always 
    @(sel0 or data0 or data1) 
      case ({sel0})
       1'b0: z = data0;
       1'b1: z = data1;
      endcase
endmodule
`else
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  wire z;
  wire inv_sel0, w_0, w_1;
  not i_0 (inv_sel0, sel0);
  and a_0 (w_0, inv_sel0, data0);
  and a_1 (w_1, sel0, data1);
  or org (z, w_0, w_1);
endmodule
`endif // ONE_HOT_MUX
`endif
